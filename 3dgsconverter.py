import argparse
import numpy as np
from plyfile import PlyData, PlyElement
from tqdm import tqdm
from collections import deque

# Define constant headers for gs3d and cc formats
# (Headers are automatically generated by the plyfile library, so we don't need them here)

def text_based_detect_format(file_path):
    """Detect if the given file is in 'gs3d' or 'cc' format."""
    with open(file_path, 'rb') as file:
        header_bytes = file.read(2048)  # Read the beginning to detect the format

    header = header_bytes.decode('utf-8', errors='ignore')
    if "property float f_dc_0" in header:
        return "gs3d"
    elif "property float scal_f_dc_0" in header:
        return "cc"
    else:
        return None

def create_new_ply(input_path, output_path, detected_format, vertices):
    """Create a new PLY file with the opposite header of the detected format and binary data from the original."""
    
    chunk_size = 10000  # Number of vertices to process in each chunk
    all_processed_data = []

    for start_idx in tqdm(range(0, len(vertices), chunk_size), desc="Processing"):
        end_idx = start_idx + chunk_size
        chunk = vertices[start_idx:end_idx]

        # Extracting existing data
        x = chunk['x']
        y = chunk['y']
        z = chunk['z']
        nx = chunk['nx']
        ny = chunk['ny']
        nz = chunk['nz']
        f_dc_0 = chunk['f_dc_0']
        f_dc_1 = chunk['f_dc_1']
        f_dc_2 = chunk['f_dc_2']
        f_rest = [chunk[f'f_rest_{i}'] for i in range(45)]
        opacity = chunk['opacity']
        scale_0 = chunk['scale_0']
        scale_1 = chunk['scale_1']
        scale_2 = chunk['scale_2']
        rot_0 = chunk['rot_0']
        rot_1 = chunk['rot_1']
        rot_2 = chunk['rot_2']
        rot_3 = chunk['rot_3']

        # Creating the new PLY data chunk
        chunk_data = np.array(list(zip(x, y, z, nx, ny, nz, 
                                    f_dc_0, f_dc_1, f_dc_2, 
                                    *f_rest, 
                                    opacity, 
                                    scale_0, scale_1, scale_2, 
                                    rot_0, rot_1, rot_2, rot_3)),
                        dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4'), 
                                ('nx', 'f4'), ('ny', 'f4'), ('nz', 'f4'), 
                                ('scal_f_dc_0', 'f4'), ('scal_f_dc_1', 'f4'), ('scal_f_dc_2', 'f4'), 
                                *[(f'scal_f_rest_{i}', 'f4') for i in range(45)], 
                                ('scal_opacity', 'f4'), 
                                ('scal_scale_0', 'f4'), ('scal_scale_1', 'f4'), ('scal_scale_2', 'f4'), 
                                ('scal_rot_0', 'f4'), ('scal_rot_1', 'f4'), ('scal_rot_2', 'f4'), ('scal_rot_3', 'f4')])

        all_processed_data.append(chunk_data)

    # Concatenate all processed chunks together
    final_data = np.concatenate(all_processed_data)

    new_plydata = PlyData([PlyElement.describe(final_data, 'vertex')], byte_order='=')
    new_plydata.write(output_path)

def create_new_ply_with_header(input_path, output_path, detected_format, vertices=None):
    """Create a new PLY file with the opposite header of the detected format and binary data from the original."""
    
    # If vertices are not provided, read from the input file
    if vertices is None:
        plydata = PlyData.read(input_path)
        vertices = plydata['vertex'].data
    
    chunk_size = 10000  # Number of vertices to process in each chunk
    all_processed_data = []

    # Determine if RGB processing is needed
    process_rgb = (detected_format == "gs3d")
    
    for start_idx in tqdm(range(0, len(vertices), chunk_size), desc="Processing", unit="chunks"):
        end_idx = start_idx + chunk_size
        chunk = vertices[start_idx:end_idx]

        if process_rgb:
            colors = []
            for vertex in chunk:
                # Depending on the detected format, use the appropriate field names
                if detected_format == "gs3d":
                    f_dc = np.array([vertex['f_dc_0'], vertex['f_dc_1'], vertex['f_dc_2']])
                else:
                    f_dc = np.array([vertex['scal_f_dc_0'], vertex['scal_f_dc_1'], vertex['scal_f_dc_2']])
                    
                color = (f_dc + 1) * 127.5
                color = np.clip(color, 0, 255).astype(np.uint8)
                colors.append(color)
            colors = np.array(colors)
        else:
            colors = np.zeros((len(chunk), 3), dtype=np.uint8)

        # Extracting existing data
        x = chunk['x']
        y = chunk['y']
        z = chunk['z']
        nx = chunk['nx']
        ny = chunk['ny']
        nz = chunk['nz']
        f_dc_0 = chunk['f_dc_0']
        f_dc_1 = chunk['f_dc_1']
        f_dc_2 = chunk['f_dc_2']
        f_rest = [chunk[f'f_rest_{i}'] for i in range(45)]
        opacity = chunk['opacity']
        scale_0 = chunk['scale_0']
        scale_1 = chunk['scale_1']
        scale_2 = chunk['scale_2']
        rot_0 = chunk['rot_0']
        rot_1 = chunk['rot_1']
        rot_2 = chunk['rot_2']
        rot_3 = chunk['rot_3']
        
        r = colors[:, 0]
        g = colors[:, 1]
        b = colors[:, 2]

        # Creating the new PLY
        chunk_data = np.array(list(zip(x, y, z, nx, ny, nz, 
                                    f_dc_0, f_dc_1, f_dc_2, 
                                    *f_rest, 
                                    opacity, 
                                    scale_0, scale_1, scale_2, 
                                    rot_0, rot_1, rot_2, rot_3, 
                                    r, g, b)),
                        dtype=[('x', 'f4'), ('y', 'f4'), ('z', 'f4'), 
                                ('nx', 'f4'), ('ny', 'f4'), ('nz', 'f4'), 
                                ('scal_f_dc_0', 'f4'), ('scal_f_dc_1', 'f4'), ('scal_f_dc_2', 'f4'), 
                                *[(f'scal_f_rest_{i}', 'f4') for i in range(45)], 
                                ('scal_opacity', 'f4'), 
                                ('scal_scale_0', 'f4'), ('scal_scale_1', 'f4'), ('scal_scale_2', 'f4'), 
                                ('scal_rot_0', 'f4'), ('scal_rot_1', 'f4'), ('scal_rot_2', 'f4'), ('scal_rot_3', 'f4'), 
                                ('red', 'u1'), ('green', 'u1'), ('blue', 'u1')])
        
        all_processed_data.append(chunk_data)

    # Concatenate all processed chunks together
    final_data = np.concatenate(all_processed_data)

    new_plydata = PlyData([PlyElement.describe(final_data, 'vertex')], byte_order='=')
    new_plydata.write(output_path)

def get_neighbors(voxel_coords):
    """Get the face-touching neighbors of the given voxel coordinates."""
    x, y, z = voxel_coords
    neighbors = [
        (x-1, y, z), (x+1, y, z),
        (x, y-1, z), (x, y+1, z),
        (x, y, z-1), (x, y, z+1)
    ]
    return neighbors

def apply_density_filter(vertices, voxel_size=1.0, threshold=15000):
    """
    Filter the vertices to keep only those in denser regions and from the largest contiguous voxel cluster.
    
    Parameters:
    - vertices: The vertices of the point cloud.
    - voxel_size: The size of the voxels used for density calculation.
    - threshold: The minimum number of points a voxel must contain to be considered "dense".
    
    Returns:
    - Filtered vertices as a structured numpy array.
    - Number of filtered vertices.
    """
    # Create a dictionary to count points in each voxel
    voxel_counts = {}
    
    for vertex in vertices:
        # Compute the voxel coordinates for each vertex
        voxel_coords = (int(vertex['x'] / voxel_size), int(vertex['y'] / voxel_size), int(vertex['z'] / voxel_size))
        if voxel_coords in voxel_counts:
            voxel_counts[voxel_coords] += 1
        else:
            voxel_counts[voxel_coords] = 1

    # Filter out voxels based on density threshold
    dense_voxels = {k: v for k, v in voxel_counts.items() if v >= threshold}

    # Identify the largest contiguous voxel cluster
    visited = set()
    max_cluster = set()
    for voxel in dense_voxels:
        if voxel not in visited:
            current_cluster = set()
            queue = deque([voxel])
            while queue:
                current_voxel = queue.popleft()
                visited.add(current_voxel)
                current_cluster.add(current_voxel)
                for neighbor in get_neighbors(current_voxel):
                    if neighbor in dense_voxels and neighbor not in visited:
                        queue.append(neighbor)
                        visited.add(neighbor)
            if len(current_cluster) > len(max_cluster):
                max_cluster = current_cluster

    # Filter vertices to retain only those from the largest contiguous voxel cluster
    filtered_vertices = [vertex for vertex in vertices if (int(vertex['x'] / voxel_size), int(vertex['y'] / voxel_size), int(vertex['z'] / voxel_size)) in max_cluster]

    # Convert the list of filtered vertices back to a structured numpy array
    filtered_vertices_array = np.array(filtered_vertices, dtype=vertices.dtype)

    return filtered_vertices_array, len(filtered_vertices_array)


def main():
    parser = argparse.ArgumentParser(description="Detect point cloud format: standard 3d gaussian splat or 3d gaussian splat for cloud compare and create a new file with the opposite header.")
    parser.add_argument("input_file", help="Path to the point cloud file.")
    parser.add_argument("output_file", help="Path to save the new point cloud file with the opposite header.")
    parser.add_argument("--rgb", action="store_true", help="Add RGB values to the output file based on f_dc values.")
    parser.add_argument("--density_filter", action="store_true", help="Filter the points to keep only regions with higher point density.")
    args = parser.parse_args()
    
    format_display_names = {
        "gs3d": "standard 3D Gaussian Splat",
        "cc": "3d Gaussian Splat for Cloud Compare"
    }

    detected_format = text_based_detect_format(args.input_file)
    
    if detected_format:
        print(f"Detected format of input file: {format_display_names[detected_format]}")

        plydata = PlyData.read(args.input_file)
        vertices = plydata['vertex'].data
        print(f"Initial number of vertices: {len(vertices)}")
        
        if args.density_filter:
            print("Applying density filter...")
            vertices, filtered_count = apply_density_filter(vertices)
            print(f"Number of vertices after density filter: {filtered_count}")
        
        if args.rgb:
            create_new_ply_with_header(args.input_file, args.output_file, detected_format, vertices)
        else:
            # Just write with the updated header
            print(f"Number of vertices before writing: {len(vertices)}")  # Add this line here
            create_new_ply(args.input_file, args.output_file, detected_format, vertices)
        
        print(f"Created new PLY file with {len(vertices)} vertices: {args.output_file}")
    else:
        print("The provided file is not a recognized 3d gaussian splat point cloud format.")

if __name__ == "__main__":
    main()